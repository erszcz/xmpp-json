-module(mongoose_json_SUITE).

-compile([export_all]).

-include_lib("common_test/include/ct.hrl").
-include_lib("proper/include/proper.hrl").
-include_lib("eunit/include/eunit.hrl").
-include_lib("exml/include/exml.hrl").

-define(a(E), ?assert(E)).
-define(ae(E, A), ?assertEqual(E, A)).

all() ->
    [{group, exml_json},
     {group, properties}].

groups() ->
    [{exml_json, [identity_no_attrs_no_children_test,
                  identity_no_attrs_with_children_test,
                  identity_with_attrs_no_children_test,
                  identity_with_attrs_with_children_test,
                  xmlel_from_json_with_no_attrs_no_children,
                  xmlel_from_json_with_no_attrs,
                  xmlel_from_json_with_no_children]},
     {properties, [identity,
                   mixed_identity]}].

%%
%% Tests
%%

identity_no_attrs_no_children_test(_) ->
    identity_test(no_attrs, no_children).

identity_no_attrs_with_children_test(_) ->
    identity_test(no_attrs, with_children).

identity_with_attrs_no_children_test(_) ->
    identity_test(with_attrs, no_children).

identity_with_attrs_with_children_test(_) ->
    identity_test(with_attrs, with_children).

identity_test(Attrs, Children) ->
    Enc = fun mongoose_json:xmlel_to_json/1,
    Dec = fun mongoose_json:json_to_xmlel/1,
    El = static_xmlel(Attrs, Children),
    ?ae(El, Dec(Enc(El))).

xmlel_from_json_with_no_attrs_no_children(_) ->
    JSON = <<"{\"name\": \"query\"}">>,
    ?ae(#xmlel{name = <<"query">>}, mongoose_json:json_to_xmlel(JSON)).

xmlel_from_json_with_no_attrs(_) ->
    JSON = <<"{\"name\"    : \"iq\",
               \"children\": [{\"name\": \"query\"}]}">>,
    ?ae(#xmlel{name = <<"iq">>,
               children = [#xmlel{name = <<"query">>}]},
        mongoose_json:json_to_xmlel(JSON)).

xmlel_from_json_with_no_children(_) ->
    JSON = <<"{\"name\" : \"query\",
               \"attrs\": {\"xmlns\":\"cdk:xmpp:frequent-contacts\"}}">>,
    ?ae(#xmlel{name = <<"query">>,
               attrs = [{<<"xmlns">>, <<"cdk:xmpp:frequent-contacts">>}]},
        mongoose_json:json_to_xmlel(JSON)).

identity(_) ->
    property(identity, ?FORALL(El, xmlel(), dec_enc(El))).

dec_enc(El) ->
    Enc = fun mongoose_json:xmlel_to_json/1,
    Dec = fun mongoose_json:json_to_xmlel/1,
    El =:= Dec(Enc(El)).

%% Test for randomized order of JSONized XMPP element fields.
%%
%% For example, this is JSON generated by xmlel_to_json:
%%
%%   {"name"    : "iq",
%%    "attrs"   : {"from": "localhost",
%%                 "to"  : "alice@localhost/escalus-default-resource",
%%                 "type": "result"},
%%    "children": [{"cdata": "  "},
%%                 {"name"    : "query",
%%                  "attrs"   : {"xmlns":"cdk:xmpp:frequent-contacts"},
%%                  "children": []}]}
%%
%% But legal JSON might also look like this:
%%
%%   {"attrs"   : {"from": "localhost",
%%                 "to"  : "alice@localhost/escalus-default-resource",
%%                 "type": "result"},
%%    "name"    : "iq",
%%    "children": [{"cdata": "  "},
%%                 {"name"    : "query",
%%                  "attrs"   : {"xmlns":"cdk:xmpp:frequent-contacts"},
%%                  "children": []}]}
mixed_identity(_) ->
    property(mixed_identity, ?FORALL(El, xmlel(), dec_mix_enc(El))).

dec_mix_enc(El) ->
    Enc = fun mongoose_json:xmlel_to_mochistruct/1,
    Dec = fun mongoose_json:mochistruct_to_xmlel/1,
    Mix = fun ({struct, Items}) -> {struct, shuffle(Items)} end,
    El =:= Dec(Mix(Enc(El))).

%%
%% Helpers
%%

static_xmlel(no_attrs, no_children) ->
    #xmlel{name = <<"elem">>};
static_xmlel(no_attrs, with_children) ->
    #xmlel{name = <<"elem">>,
           children = [#xmlel{name = <<"with-subelem">>}]};
static_xmlel(with_attrs, no_children) ->
    #xmlel{name = <<"elem">>,
           attrs = [{<<"with">>, <<"attr1">>},
                    {<<"and">>, <<"attr2">>}]};
static_xmlel(with_attrs, with_children) ->
    #xmlel{name = <<"elem">>,
           attrs = [{<<"with">>, <<"attr1">>},
                    {<<"and">>, <<"attr2">>}],
           children = [#xmlel{name = <<"with-subelem">>}]}.

property(Name, Prop) ->
    Props = proper:conjunction([{Name, Prop}]),
    ?a(proper:quickcheck(Props, [verbose, long_result, {numtests, 50}])).

%%
%% Generators
%%

ascii_text() ->
    non_empty(list(choose($a, $z))).

xmlel_attr() ->
    ?LET({Key, Val}, {ascii_text(), ascii_text()},
         {list_to_binary(Key), list_to_binary(Val)}).

xmlel_attrs() ->
    ?LET(Len, choose(0, 5), vector(Len, xmlel_attr())).

xmlel() ->
    ?SIZED(Size, xmlel(Size)).

xmlel(0) ->
    ?LET({Name, Attrs}, {ascii_text(), xmlel_attrs()},
         #xmlel{name = list_to_binary(Name),
                attrs = Attrs});
xmlel(Size) ->
    ?LET({Name, Attrs}, {ascii_text(), xmlel_attrs()},
         #xmlel{name = list_to_binary(Name),
                attrs = Attrs,
                children = xmlel_children(Size)}).

xmlel_children(Size) ->
    ?LET(Len, choose(0, 5), vector(Len, xmlel_child(Size))).

xmlel_child(Size) ->
    ?LET(CData, ascii_text(),
         oneof([#xmlcdata{content = list_to_binary(CData)},
                xmlel(Size div 3)])).

%% @doc Returns a list in random order.
shuffle(List) when is_list(List) ->
    WithKey = [ {random:uniform(), X} || X <- List ],
    Sorted = lists:keysort(1, WithKey),
    keys(2, Sorted).

%% @doc Apply `element(N, _)' for each element.
keys(N, List) ->
    [element(N, X) || X <- List].
